/* tslint:disable */
/* eslint-disable */
/**
 * github-sls-rest-api
 * To generate a JWT token, go to the <a href=\"https://sso.saml.to/auth/jwt.html\" target=\"_blank\">JWT Token Generator</a>
 *
 * The version of the OpenAPI document: 1.0.104-27
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface GithubSlsRestApiAssumeBrowserResponse
 */
export interface GithubSlsRestApiAssumeBrowserResponse {
    /**
     * 
     * @type {GithubSlsRestApiChallenge}
     * @memberof GithubSlsRestApiAssumeBrowserResponse
     */
    'challenge'?: GithubSlsRestApiChallenge;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAssumeBrowserResponse
     */
    'browserUri': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiAuditTypeV1
 */
export interface GithubSlsRestApiAuditTypeV1 {
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiAuditV1
 */
export interface GithubSlsRestApiAuditV1 {
    /**
     * 
     * @type {Array<GithubSlsRestApiAuditTypeV1>}
     * @memberof GithubSlsRestApiAuditV1
     */
    'types'?: Array<GithubSlsRestApiAuditTypeV1>;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuditV1
     */
    'destination'?: string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
 */
export interface GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1 {
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1VersionEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
     */
    'version': GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1VersionEnum;
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1TypeEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
     */
    'type': GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1TypeEnum;
    /**
     * 
     * @type {object}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
     */
    'state': object;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
     */
    'installationId': number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
     */
    'appId': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1
     */
    'target': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1TypeEnum {
    GithubInstallationEvent = 'GithubInstallationEvent'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubInstallationEventV1VersionEnum {
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
 */
export interface GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1 {
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'version': GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum;
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'type': GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'installationId'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'appId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1
     */
    'login': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum {
    GithubLoginTokenEvent = 'GithubLoginTokenEvent'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum {
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
 */
export interface GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1 {
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1VersionEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'version': GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1VersionEnum;
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1TypeEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'type': GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'team': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'login': string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'appId': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1
     */
    'target': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1TypeEnum {
    GithubMembershipEvent = 'GithubMembershipEvent'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubMembershipEventV1VersionEnum {
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
 */
export interface GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1 {
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1VersionEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
     */
    'version': GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1VersionEnum;
    /**
     * 
     * @type {GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1TypeEnum}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
     */
    'type': GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
     */
    'removed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
     */
    'login': string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
     */
    'appId': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1
     */
    'target': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1TypeEnum {
    GithubTargetMembershipEvent = 'GithubTargetMembershipEvent'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiAuthSlsRestApiGithubTargetMembershipEventV1VersionEnum {
    NUMBER_1 = 1
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiAwsAssumeSdkOptions
 */
export interface GithubSlsRestApiAwsAssumeSdkOptions {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiAwsAssumeSdkOptions
     */
    'DurationSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAwsAssumeSdkOptions
     */
    'RoleArn': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiAwsAssumeSdkOptions
     */
    'PrincipalArn': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiBaseEventCacheClearRequest1
 */
export interface GithubSlsRestApiBaseEventCacheClearRequest1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiBaseEventCacheClearRequest1
     */
    'version': GithubSlsRestApiBaseEventCacheClearRequest1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiBaseEventCacheClearRequest1
     */
    'type': GithubSlsRestApiBaseEventCacheClearRequest1TypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventCacheClearRequest1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventCacheClearRequest1TypeEnum {
    CacheClearRequest = 'CacheClearRequest'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiBaseEventConfigChanged1
 */
export interface GithubSlsRestApiBaseEventConfigChanged1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiBaseEventConfigChanged1
     */
    'version': GithubSlsRestApiBaseEventConfigChanged1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiBaseEventConfigChanged1
     */
    'type': GithubSlsRestApiBaseEventConfigChanged1TypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventConfigChanged1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventConfigChanged1TypeEnum {
    ConfigChanged = 'ConfigChanged'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiBaseEventIdpCertificate1
 */
export interface GithubSlsRestApiBaseEventIdpCertificate1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiBaseEventIdpCertificate1
     */
    'version': GithubSlsRestApiBaseEventIdpCertificate1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiBaseEventIdpCertificate1
     */
    'type': GithubSlsRestApiBaseEventIdpCertificate1TypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventIdpCertificate1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventIdpCertificate1TypeEnum {
    IdpCertificate = 'IdpCertificate'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiBaseEventTotp1
 */
export interface GithubSlsRestApiBaseEventTotp1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiBaseEventTotp1
     */
    'version': GithubSlsRestApiBaseEventTotp1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiBaseEventTotp1
     */
    'type': GithubSlsRestApiBaseEventTotp1TypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventTotp1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiBaseEventTotp1TypeEnum {
    Totp = 'Totp'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiCacheClearRequestEventV1
 */
export interface GithubSlsRestApiCacheClearRequestEventV1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1
     */
    'version': GithubSlsRestApiCacheClearRequestEventV1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1
     */
    'type': GithubSlsRestApiCacheClearRequestEventV1TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1
     */
    'appId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1
     */
    'org': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiCacheClearRequestEventV1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiCacheClearRequestEventV1TypeEnum {
    CacheClearRequest = 'CacheClearRequest'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiCacheClearRequestEventV1AllOf
 */
export interface GithubSlsRestApiCacheClearRequestEventV1AllOf {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1AllOf
     */
    'appId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1AllOf
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCacheClearRequestEventV1AllOf
     */
    'org': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiChallenge
 */
export interface GithubSlsRestApiChallenge {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiChallenge
     */
    'recipient'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiChallenge
     */
    'invitation'?: string;
    /**
     * 
     * @type {Array<GithubSlsRestApiTotpMethod>}
     * @memberof GithubSlsRestApiChallenge
     */
    'methods': Array<GithubSlsRestApiTotpMethod>;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiChallenge
     */
    'org': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiCloudFormationGetAtt
 */
export interface GithubSlsRestApiCloudFormationGetAtt {
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubSlsRestApiCloudFormationGetAtt
     */
    'Fn::GetAtt': Array<string>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiCloudFormationHookEventV1
 */
export interface GithubSlsRestApiCloudFormationHookEventV1 {
    /**
     * 
     * @type {string | GithubSlsRestApiCloudFormationGetAtt}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'roleName'?: string | GithubSlsRestApiCloudFormationGetAtt;
    /**
     * 
     * @type {string | GithubSlsRestApiCloudFormationGetAtt}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'roleArn'?: string | GithubSlsRestApiCloudFormationGetAtt;
    /**
     * 
     * @type {string | GithubSlsRestApiCloudFormationGetAtt}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'providerArn': string | GithubSlsRestApiCloudFormationGetAtt;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'stage': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'templateId': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'org': string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'version': GithubSlsRestApiCloudFormationHookEventV1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'type': GithubSlsRestApiCloudFormationHookEventV1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationHookEventV1
     */
    'ServiceToken': string;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiCloudFormationHookEventV1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiCloudFormationHookEventV1TypeEnum {
    CloudFormationHookEvent = 'CloudFormationHookEvent'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiCloudFormationResponse
 */
export interface GithubSlsRestApiCloudFormationResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationResponse
     */
    'roleName'?: string;
    /**
     * 
     * @type {Array<GithubSlsRestApiConfigVariable>}
     * @memberof GithubSlsRestApiCloudFormationResponse
     */
    'configVariables'?: Array<GithubSlsRestApiConfigVariable>;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiCloudFormationResponse
     */
    'pollInterval': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationResponse
     */
    'cloudFormationUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationResponse
     */
    'templateUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiCloudFormationResponse
     */
    'templateId': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigBaseSupportedVersions
 */
export interface GithubSlsRestApiConfigBaseSupportedVersions {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'ts'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'repo'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'org'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'shaRendered'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'commitSha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'path'?: string;
    /**
     * 
     * @type {GithubSlsRestApiSupportedVersions}
     * @memberof GithubSlsRestApiConfigBaseSupportedVersions
     */
    'version': GithubSlsRestApiSupportedVersions;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigChangedEventV1
 */
export interface GithubSlsRestApiConfigChangedEventV1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'version': GithubSlsRestApiConfigChangedEventV1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'type': GithubSlsRestApiConfigChangedEventV1TypeEnum;
    /**
     * 
     * @type {GithubSlsRestApiConfigChangedEventV1AllOfPrevious}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'previous': GithubSlsRestApiConfigChangedEventV1AllOfPrevious;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'configSha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'org': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubSlsRestApiConfigChangedEventV1
     */
    'states': Array<GithubSlsRestApiConfigChangedEventV1StatesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiConfigChangedEventV1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiConfigChangedEventV1TypeEnum {
    ConfigChanged = 'ConfigChanged'
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiConfigChangedEventV1StatesEnum {
    ShaChanged = 'SHA_CHANGED'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigChangedEventV1AllOf
 */
export interface GithubSlsRestApiConfigChangedEventV1AllOf {
    /**
     * 
     * @type {GithubSlsRestApiConfigChangedEventV1AllOfPrevious}
     * @memberof GithubSlsRestApiConfigChangedEventV1AllOf
     */
    'previous': GithubSlsRestApiConfigChangedEventV1AllOfPrevious;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1AllOf
     */
    'configSha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1AllOf
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1AllOf
     */
    'org': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubSlsRestApiConfigChangedEventV1AllOf
     */
    'states': Array<GithubSlsRestApiConfigChangedEventV1AllOfStatesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiConfigChangedEventV1AllOfStatesEnum {
    ShaChanged = 'SHA_CHANGED'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigChangedEventV1AllOfPrevious
 */
export interface GithubSlsRestApiConfigChangedEventV1AllOfPrevious {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigChangedEventV1AllOfPrevious
     */
    'configSha'?: string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigV20220101
 */
export interface GithubSlsRestApiConfigV20220101 {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'ts'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'repo'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'org'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'shaRendered'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'commitSha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'sha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'path'?: string;
    /**
     * 
     * @type {GithubSlsRestApiSupportedVersions}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'version': GithubSlsRestApiSupportedVersions;
    /**
     * 
     * @type {GithubSlsRestApiAuditV1}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'audit'?: GithubSlsRestApiAuditV1;
    /**
     * 
     * @type {GithubSlsRestApiGithubV1}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'github'?: GithubSlsRestApiGithubV1;
    /**
     * 
     * @type {GithubSlsRestApiTwoFactorV1}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'twoFactor'?: GithubSlsRestApiTwoFactorV1;
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiPermissionV1; }}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'permissions'?: { [key: string]: GithubSlsRestApiPermissionV1; };
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiProviderV1; }}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'providers'?: { [key: string]: GithubSlsRestApiProviderV1; };
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiVariableV1; }}
     * @memberof GithubSlsRestApiConfigV20220101
     */
    'variables'?: { [key: string]: GithubSlsRestApiVariableV1; };
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigV20220101AllOf
 */
export interface GithubSlsRestApiConfigV20220101AllOf {
    /**
     * 
     * @type {GithubSlsRestApiAuditV1}
     * @memberof GithubSlsRestApiConfigV20220101AllOf
     */
    'audit'?: GithubSlsRestApiAuditV1;
    /**
     * 
     * @type {GithubSlsRestApiGithubV1}
     * @memberof GithubSlsRestApiConfigV20220101AllOf
     */
    'github'?: GithubSlsRestApiGithubV1;
    /**
     * 
     * @type {GithubSlsRestApiTwoFactorV1}
     * @memberof GithubSlsRestApiConfigV20220101AllOf
     */
    'twoFactor'?: GithubSlsRestApiTwoFactorV1;
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiPermissionV1; }}
     * @memberof GithubSlsRestApiConfigV20220101AllOf
     */
    'permissions'?: { [key: string]: GithubSlsRestApiPermissionV1; };
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiProviderV1; }}
     * @memberof GithubSlsRestApiConfigV20220101AllOf
     */
    'providers'?: { [key: string]: GithubSlsRestApiProviderV1; };
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiVariableV1; }}
     * @memberof GithubSlsRestApiConfigV20220101AllOf
     */
    'variables'?: { [key: string]: GithubSlsRestApiVariableV1; };
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigVariable
 */
export interface GithubSlsRestApiConfigVariable {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigVariable
     */
    'awsRoleArn'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigVariable
     */
    'awsProviderArn': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiConfigVariable
     */
    'awsAccountId': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConfigVariablesResponse
 */
export interface GithubSlsRestApiConfigVariablesResponse {
    /**
     * 
     * @type {Array<GithubSlsRestApiConfigVariable>}
     * @memberof GithubSlsRestApiConfigVariablesResponse
     */
    'results': Array<GithubSlsRestApiConfigVariable>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConsolidateRequest
 */
export interface GithubSlsRestApiConsolidateRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubSlsRestApiConsolidateRequest
     */
    'repos'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiConsolidateResponse
 */
export interface GithubSlsRestApiConsolidateResponse {
    /**
     * 
     * @type {GithubSlsRestApiConfigV20220101}
     * @memberof GithubSlsRestApiConsolidateResponse
     */
    'after': GithubSlsRestApiConfigV20220101;
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiConfigV20220101; }}
     * @memberof GithubSlsRestApiConsolidateResponse
     */
    'before': { [key: string]: GithubSlsRestApiConfigV20220101; };
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiEncryptRequest
 */
export interface GithubSlsRestApiEncryptRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiEncryptRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiEncryptResponse
 */
export interface GithubSlsRestApiEncryptResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiEncryptResponse
     */
    'encryptedValue': string;
}
/**
 * This file was automatically generated by joi-to-typescript Do not modify this file manually
 * @export
 * @interface GithubSlsRestApiEncryptedField
 */
export interface GithubSlsRestApiEncryptedField {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiEncryptedField
     */
    'encryptedValue': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiEncryptedField
     */
    'keyId': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiErrorResponse
 */
export interface GithubSlsRestApiErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiErrorResponse
     */
    'traceId': string;
    /**
     * 
     * @type {GithubSlsRestApiErrorResponseTracking}
     * @memberof GithubSlsRestApiErrorResponse
     */
    'tracking': GithubSlsRestApiErrorResponseTracking;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GithubSlsRestApiErrorResponse
     */
    'context'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiErrorResponseTracking
 */
export interface GithubSlsRestApiErrorResponseTracking {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiErrorResponseTracking
     */
    'method': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiErrorResponseTracking
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiErrorResponseTracking
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiGithubUserResponse
 */
export interface GithubSlsRestApiGithubUserResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiGithubUserResponse
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiGithubV1
 */
export interface GithubSlsRestApiGithubV1 {
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiGithubV1
     */
    'requireMembership'?: boolean;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiHealthResponse
 */
export interface GithubSlsRestApiHealthResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiHealthResponse
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiHealthResponse
     */
    'now': string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiHealthResponse
     */
    'healty': boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiHealthResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiIdentityResponse
 */
export interface GithubSlsRestApiIdentityResponse {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'twoFactorTtl'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdentityResponse
     */
    'clientId': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiIdpCertificateEventV1
 */
export interface GithubSlsRestApiIdpCertificateEventV1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiIdpCertificateEventV1
     */
    'version': GithubSlsRestApiIdpCertificateEventV1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1
     */
    'type': GithubSlsRestApiIdpCertificateEventV1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1
     */
    'serial': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1
     */
    'state': GithubSlsRestApiIdpCertificateEventV1StateEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiIdpCertificateEventV1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiIdpCertificateEventV1TypeEnum {
    IdpCertificate = 'IdpCertificate'
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiIdpCertificateEventV1StateEnum {
    Updated = 'UPDATED'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiIdpCertificateEventV1AllOf
 */
export interface GithubSlsRestApiIdpCertificateEventV1AllOf {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1AllOf
     */
    'serial': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1AllOf
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1AllOf
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpCertificateEventV1AllOf
     */
    'state': GithubSlsRestApiIdpCertificateEventV1AllOfStateEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiIdpCertificateEventV1AllOfStateEnum {
    Updated = 'UPDATED'
}

/**
 * This file was automatically generated by joi-to-typescript Do not modify this file manually
 * @export
 * @interface GithubSlsRestApiIdpOrgRepoCert
 */
export interface GithubSlsRestApiIdpOrgRepoCert {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'caCertificate': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'certificate': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'serial': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiIdpOrgRepoCert
     */
    'sk': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiListResponseLoginResponse
 */
export interface GithubSlsRestApiListResponseLoginResponse {
    /**
     * 
     * @type {GithubSlsRestApiListResponseOrgRepoConfigResponseNext}
     * @memberof GithubSlsRestApiListResponseLoginResponse
     */
    'next'?: GithubSlsRestApiListResponseOrgRepoConfigResponseNext;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseLoginResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseLoginResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GithubSlsRestApiLoginResponse>}
     * @memberof GithubSlsRestApiListResponseLoginResponse
     */
    'results': Array<GithubSlsRestApiLoginResponse>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiListResponseOrgRepoConfigResponse
 */
export interface GithubSlsRestApiListResponseOrgRepoConfigResponse {
    /**
     * 
     * @type {GithubSlsRestApiListResponseOrgRepoConfigResponseNext}
     * @memberof GithubSlsRestApiListResponseOrgRepoConfigResponse
     */
    'next'?: GithubSlsRestApiListResponseOrgRepoConfigResponseNext;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseOrgRepoConfigResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseOrgRepoConfigResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GithubSlsRestApiOrgRepoConfigResponse>}
     * @memberof GithubSlsRestApiListResponseOrgRepoConfigResponse
     */
    'results': Array<GithubSlsRestApiOrgRepoConfigResponse>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiListResponseOrgRepoConfigResponseNext
 */
export interface GithubSlsRestApiListResponseOrgRepoConfigResponseNext {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiListResponseOrgRepoConfigResponseNext
     */
    'sk': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiListResponseOrgRepoConfigResponseNext
     */
    'pk': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiListResponseOrgRepoResponse
 */
export interface GithubSlsRestApiListResponseOrgRepoResponse {
    /**
     * 
     * @type {GithubSlsRestApiListResponseOrgRepoConfigResponseNext}
     * @memberof GithubSlsRestApiListResponseOrgRepoResponse
     */
    'next'?: GithubSlsRestApiListResponseOrgRepoConfigResponseNext;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseOrgRepoResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseOrgRepoResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GithubSlsRestApiOrgRepoResponse>}
     * @memberof GithubSlsRestApiListResponseOrgRepoResponse
     */
    'results': Array<GithubSlsRestApiOrgRepoResponse>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiListResponseRoleResponse
 */
export interface GithubSlsRestApiListResponseRoleResponse {
    /**
     * 
     * @type {GithubSlsRestApiListResponseOrgRepoConfigResponseNext}
     * @memberof GithubSlsRestApiListResponseRoleResponse
     */
    'next'?: GithubSlsRestApiListResponseOrgRepoConfigResponseNext;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseRoleResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiListResponseRoleResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GithubSlsRestApiRoleResponse>}
     * @memberof GithubSlsRestApiListResponseRoleResponse
     */
    'results': Array<GithubSlsRestApiRoleResponse>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiLoginResponse
 */
export interface GithubSlsRestApiLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponse
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponse
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponse
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponse
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponse
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiLoginResponseContainer
 */
export interface GithubSlsRestApiLoginResponseContainer {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponseContainer
     */
    'browserUri': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponseContainer
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponseContainer
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginResponseContainer
     */
    'org': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiLoginToken
 */
export interface GithubSlsRestApiLoginToken {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginToken
     */
    'email'?: string;
    /**
     * 
     * @type {GithubSlsRestApiEncryptedField}
     * @memberof GithubSlsRestApiLoginToken
     */
    'encryptedToken': GithubSlsRestApiEncryptedField;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginToken
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginToken
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginToken
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginToken
     */
    'scopes'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiLoginToken
     */
    'sk': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiMetadataResponse
 */
export interface GithubSlsRestApiMetadataResponse {
    /**
     * 
     * @type {Array<GithubSlsRestApiGithubUserResponse>}
     * @memberof GithubSlsRestApiMetadataResponse
     */
    'admins': Array<GithubSlsRestApiGithubUserResponse>;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiMetadataResponse
     */
    'certificate': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiMetadataResponse
     */
    'logoutUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiMetadataResponse
     */
    'loginUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiMetadataResponse
     */
    'entityId': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiMetadataResponse
     */
    'metadataXml': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiNameIdFormatV1 {
    Id = 'id',
    Login = 'login',
    Email = 'email',
    EmailV2 = 'emailV2'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgLoginTotp
 */
export interface GithubSlsRestApiOrgLoginTotp {
    /**
     * 
     * @type {GithubSlsRestApiEncryptedField}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'encryptedInvitation'?: GithubSlsRestApiEncryptedField | null;
    /**
     * 
     * @type {GithubSlsRestApiEncryptedField}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'encryptedSecret'?: GithubSlsRestApiEncryptedField;
    /**
     * 
     * @type {GithubSlsRestApiEncryptedField}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'encryptedUri'?: GithubSlsRestApiEncryptedField;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'expires'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'initialFrequency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'login': string;
    /**
     * 
     * @type {GithubSlsRestApiTotpMethod | string}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'method'?: GithubSlsRestApiTotpMethod | string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgLoginTotp
     */
    'sk': string;
}
/**
 * This file was automatically generated by joi-to-typescript Do not modify this file manually
 * @export
 * @interface GithubSlsRestApiOrgRepo
 */
export interface GithubSlsRestApiOrgRepo {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'appId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'baseUrl': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'configSha'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'configShaRendered'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'installationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'org': string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'orgId': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'repo': string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'repoId': number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepo
     */
    'sk': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgRepoConfigListResponse
 */
export interface GithubSlsRestApiOrgRepoConfigListResponse {
    /**
     * 
     * @type {GithubSlsRestApiListResponseOrgRepoConfigResponseNext}
     * @memberof GithubSlsRestApiOrgRepoConfigListResponse
     */
    'next'?: GithubSlsRestApiListResponseOrgRepoConfigResponseNext;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepoConfigListResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepoConfigListResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GithubSlsRestApiOrgRepoConfigResponse>}
     * @memberof GithubSlsRestApiOrgRepoConfigListResponse
     */
    'results': Array<GithubSlsRestApiOrgRepoConfigResponse>;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigListResponse
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgRepoConfigListResponseAllOf
 */
export interface GithubSlsRestApiOrgRepoConfigListResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigListResponseAllOf
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgRepoConfigRefreshResponse
 */
export interface GithubSlsRestApiOrgRepoConfigRefreshResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'sha'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'dryrun': boolean;
    /**
     * 
     * @type {GithubSlsRestApiConfigV20220101}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponse
     */
    'config': GithubSlsRestApiConfigV20220101;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf
 */
export interface GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf
     */
    'branch'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf
     */
    'sha'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf
     */
    'dryrun': boolean;
    /**
     * 
     * @type {GithubSlsRestApiConfigV20220101}
     * @memberof GithubSlsRestApiOrgRepoConfigRefreshResponseAllOf
     */
    'config': GithubSlsRestApiConfigV20220101;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgRepoConfigResponse
 */
export interface GithubSlsRestApiOrgRepoConfigResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'suspended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'installationUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'installationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'configUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'repoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'orgUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'configPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'repo'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoConfigResponse
     */
    'org': string;
}
/**
 * This file was automatically generated by joi-to-typescript Do not modify this file manually
 * @export
 * @interface GithubSlsRestApiOrgRepoLogin
 */
export interface GithubSlsRestApiOrgRepoLogin {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'appId'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'installationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'pk': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoLogin
     */
    'sk': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiOrgRepoResponse
 */
export interface GithubSlsRestApiOrgRepoResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoResponse
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiOrgRepoResponse
     */
    'org': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiPermissionAssertAuditTypeV1 {
    PermissionAssert = 'PermissionAssert'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiPermissionV1
 */
export interface GithubSlsRestApiPermissionV1 {
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiPermissionV1
     */
    'self'?: boolean;
    /**
     * 
     * @type {Array<GithubSlsRestApiRolesV1>}
     * @memberof GithubSlsRestApiPermissionV1
     */
    'roles'?: Array<GithubSlsRestApiRolesV1>;
    /**
     * 
     * @type {GithubSlsRestApiTeamsV1}
     * @memberof GithubSlsRestApiPermissionV1
     */
    'teams'?: GithubSlsRestApiTeamsV1;
    /**
     * 
     * @type {GithubSlsRestApiReposV1}
     * @memberof GithubSlsRestApiPermissionV1
     */
    'repos'?: GithubSlsRestApiReposV1;
    /**
     * 
     * @type {GithubSlsRestApiUsersV1}
     * @memberof GithubSlsRestApiPermissionV1
     */
    'users'?: GithubSlsRestApiUsersV1;
    /**
     * 
     * @type {GithubSlsRestApiProviderConfigV1}
     * @memberof GithubSlsRestApiPermissionV1
     */
    'provider'?: GithubSlsRestApiProviderConfigV1;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiProviderConfigV1
 */
export interface GithubSlsRestApiProviderConfigV1 {
    /**
     * 
     * @type {{ [key: string]: GithubSlsRestApiVariableV1; }}
     * @memberof GithubSlsRestApiProviderConfigV1
     */
    'variables'?: { [key: string]: GithubSlsRestApiVariableV1; };
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiProviderV1
 */
export interface GithubSlsRestApiProviderV1 {
    /**
     * 
     * @type {GithubSlsRestApiProvisioningV1}
     * @memberof GithubSlsRestApiProviderV1
     */
    'provisioning'?: GithubSlsRestApiProvisioningV1;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubSlsRestApiProviderV1
     */
    'attributes'?: { [key: string]: string; };
    /**
     * 
     * @type {GithubSlsRestApiNameIdFormatV1}
     * @memberof GithubSlsRestApiProviderV1
     */
    'nameIdFormat'?: GithubSlsRestApiNameIdFormatV1;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiProviderV1
     */
    'nameId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiProviderV1
     */
    'loginUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiProviderV1
     */
    'acsUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiProviderV1
     */
    'entityId'?: string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiProvisioningV1
 */
export interface GithubSlsRestApiProvisioningV1 {
    /**
     * 
     * @type {GithubSlsRestApiScimV1}
     * @memberof GithubSlsRestApiProvisioningV1
     */
    'scim'?: GithubSlsRestApiScimV1;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiRepoV1
 */
export interface GithubSlsRestApiRepoV1 {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRepoV1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiReposV1
 */
export interface GithubSlsRestApiReposV1 {
    /**
     * 
     * @type {Array<GithubSlsRestApiRepoV1 | string>}
     * @memberof GithubSlsRestApiReposV1
     */
    'github'?: Array<GithubSlsRestApiRepoV1 | string>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiRoleResponse
 */
export interface GithubSlsRestApiRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRoleResponse
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRoleResponse
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRoleResponse
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRoleResponse
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRoleResponse
     */
    'org': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRoleResponse
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiRolesV1
 */
export interface GithubSlsRestApiRolesV1 {
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiRolesV1
     */
    'self'?: boolean;
    /**
     * 
     * @type {GithubSlsRestApiProviderConfigV1}
     * @memberof GithubSlsRestApiRolesV1
     */
    'provider'?: GithubSlsRestApiProviderConfigV1;
    /**
     * 
     * @type {GithubSlsRestApiReposV1}
     * @memberof GithubSlsRestApiRolesV1
     */
    'repos'?: GithubSlsRestApiReposV1;
    /**
     * 
     * @type {GithubSlsRestApiTeamsV1}
     * @memberof GithubSlsRestApiRolesV1
     */
    'teams'?: GithubSlsRestApiTeamsV1;
    /**
     * 
     * @type {GithubSlsRestApiUsersV1}
     * @memberof GithubSlsRestApiRolesV1
     */
    'users'?: GithubSlsRestApiUsersV1;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiRolesV1
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiSAMLResponseAuditTypeV1 {
    SamlResponse = 'SAMLResponse'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiSamlHttpRequest
 */
export interface GithubSlsRestApiSamlHttpRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlHttpRequest
     */
    'contentType': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlHttpRequest
     */
    'payload': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlHttpRequest
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlHttpRequest
     */
    'method': GithubSlsRestApiSamlHttpRequestMethodEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiSamlHttpRequestMethodEnum {
    Post = 'POST'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiSamlResponseContainer
 */
export interface GithubSlsRestApiSamlResponseContainer {
    /**
     * 
     * @type {GithubSlsRestApiChallenge}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'challenge'?: GithubSlsRestApiChallenge;
    /**
     * 
     * @type {GithubSlsRestApiSamlHttpRequest}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'samlHttpRequest'?: GithubSlsRestApiSamlHttpRequest;
    /**
     * 
     * @type {GithubSlsRestApiAwsAssumeSdkOptions}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'sdkOptions'?: GithubSlsRestApiAwsAssumeSdkOptions;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'browserUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'repo': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'org': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'attributes'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'samlResponse'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'relayState': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'recipient': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSamlResponseContainer
     */
    'issuer': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiSaveConfigRequest
 */
export interface GithubSlsRestApiSaveConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSaveConfigRequest
     */
    'configYaml': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiSaveConfigResponse
 */
export interface GithubSlsRestApiSaveConfigResponse {
    /**
     * 
     * @type {GithubSlsRestApiOrgRepoConfigResponse}
     * @memberof GithubSlsRestApiSaveConfigResponse
     */
    'orgRepoConfig'?: GithubSlsRestApiOrgRepoConfigResponse;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSaveConfigResponse
     */
    'commitLink': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSaveConfigResponse
     */
    'configLink': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSaveConfigResponse
     */
    'configYaml': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiSaveConfigResponse
     */
    'sha': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiScimV1
 */
export interface GithubSlsRestApiScimV1 {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiScimV1
     */
    'encryptedToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiScimV1
     */
    'endpoint'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiSupportedVersions {
    _20220101 = '20220101'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiTeamsV1
 */
export interface GithubSlsRestApiTeamsV1 {
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubSlsRestApiTeamsV1
     */
    'github'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiTotpEventV1
 */
export interface GithubSlsRestApiTotpEventV1 {
    /**
     * 
     * @type {number}
     * @memberof GithubSlsRestApiTotpEventV1
     */
    'version': GithubSlsRestApiTotpEventV1VersionEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpEventV1
     */
    'type': GithubSlsRestApiTotpEventV1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpEventV1
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpEventV1
     */
    'org': string;
    /**
     * 
     * @type {GithubSlsRestApiTotpState}
     * @memberof GithubSlsRestApiTotpEventV1
     */
    'state': GithubSlsRestApiTotpState;
}

/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiTotpEventV1VersionEnum {
    NUMBER_1 = 1
}
/**
    * @export
    * @enum {string}
    */
export enum GithubSlsRestApiTotpEventV1TypeEnum {
    Totp = 'Totp'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiTotpEventV1AllOf
 */
export interface GithubSlsRestApiTotpEventV1AllOf {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpEventV1AllOf
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpEventV1AllOf
     */
    'org': string;
    /**
     * 
     * @type {GithubSlsRestApiTotpState}
     * @memberof GithubSlsRestApiTotpEventV1AllOf
     */
    'state': GithubSlsRestApiTotpState;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiTotpMethod {
    App = 'app',
    Email = 'email'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiTotpRequest
 */
export interface GithubSlsRestApiTotpRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpRequest
     */
    'invitation': string;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiTotpResponse
 */
export interface GithubSlsRestApiTotpResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GithubSlsRestApiTotpResponse
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpResponse
     */
    'uri'?: string;
    /**
     * 
     * @type {GithubSlsRestApiTotpMethod}
     * @memberof GithubSlsRestApiTotpResponse
     */
    'method': GithubSlsRestApiTotpMethod;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpResponse
     */
    'recipient'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTotpResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum GithubSlsRestApiTotpState {
    Invited = 'INVITED',
    Enrolled = 'ENROLLED',
    Removed = 'REMOVED'
}

/**
 * 
 * @export
 * @interface GithubSlsRestApiTwoFactorV1
 */
export interface GithubSlsRestApiTwoFactorV1 {
    /**
     * 
     * @type {string}
     * @memberof GithubSlsRestApiTwoFactorV1
     */
    'frequency'?: string;
    /**
     * 
     * @type {Array<GithubSlsRestApiTotpMethod>}
     * @memberof GithubSlsRestApiTwoFactorV1
     */
    'methods'?: Array<GithubSlsRestApiTotpMethod>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiUsersV1
 */
export interface GithubSlsRestApiUsersV1 {
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubSlsRestApiUsersV1
     */
    'github'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubSlsRestApiVariableV1
 */
export interface GithubSlsRestApiVariableV1 {
}

/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRepoConfigs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/config/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiSaveConfigRequest} githubSlsRestApiSaveConfigRequest 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConfig: async (org: string, githubSlsRestApiSaveConfigRequest: GithubSlsRestApiSaveConfigRequest, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('saveConfig', 'org', org)
            // verify required parameter 'githubSlsRestApiSaveConfigRequest' is not null or undefined
            assertParamExists('saveConfig', 'githubSlsRestApiSaveConfigRequest', githubSlsRestApiSaveConfigRequest)
            const localVarPath = `/api/v1/config/orgs/{org}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(githubSlsRestApiSaveConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgRepoConfigs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiOrgRepoConfigListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgRepoConfigs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiSaveConfigRequest} githubSlsRestApiSaveConfigRequest 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveConfig(org: string, githubSlsRestApiSaveConfigRequest: GithubSlsRestApiSaveConfigRequest, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiSaveConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveConfig(org, githubSlsRestApiSaveConfigRequest, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRepoConfigs(options?: any): AxiosPromise<GithubSlsRestApiOrgRepoConfigListResponse> {
            return localVarFp.listOrgRepoConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiSaveConfigRequest} githubSlsRestApiSaveConfigRequest 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveConfig(org: string, githubSlsRestApiSaveConfigRequest: GithubSlsRestApiSaveConfigRequest, force?: boolean, options?: any): AxiosPromise<GithubSlsRestApiSaveConfigResponse> {
            return localVarFp.saveConfig(org, githubSlsRestApiSaveConfigRequest, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public listOrgRepoConfigs(options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).listOrgRepoConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {GithubSlsRestApiSaveConfigRequest} githubSlsRestApiSaveConfigRequest 
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public saveConfig(org: string, githubSlsRestApiSaveConfigRequest: GithubSlsRestApiSaveConfigRequest, force?: boolean, options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).saveConfig(org, githubSlsRestApiSaveConfigRequest, force, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiHealthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any): AxiosPromise<GithubSlsRestApiHealthResponse> {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public get(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IDPApi - axios parameter creator
 * @export
 */
export const IDPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} role 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRole: async (role: string, org?: string, provider?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('assumeRole', 'role', role)
            const localVarPath = `/api/v1/idp/roles/{role}/assume`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} role 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRoleForBrowser: async (role: string, org?: string, provider?: string, token?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('assumeRoleForBrowser', 'role', role)
            const localVarPath = `/api/v1/idp/roles/{role}/assume/browser`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {string} role 
         * @param {string} [provider] 
         * @param {string} [commitSha] 
         * @param {string} [configOwner] 
         * @param {string} [configPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRoleForRepo: async (org: string, repo: string, role: string, provider?: string, commitSha?: string, configOwner?: string, configPath?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('assumeRoleForRepo', 'org', org)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('assumeRoleForRepo', 'repo', repo)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('assumeRoleForRepo', 'role', role)
            const localVarPath = `/api/v1/idp/orgs/{org}/repos/{repo}/roles/{role}/assume`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (commitSha !== undefined) {
                localVarQueryParameter['commitSha'] = commitSha;
            }

            if (configOwner !== undefined) {
                localVarQueryParameter['configOwner'] = configOwner;
            }

            if (configPath !== undefined) {
                localVarQueryParameter['configPath'] = configPath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encrypt: async (org: string, githubSlsRestApiEncryptRequest: GithubSlsRestApiEncryptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('encrypt', 'org', org)
            // verify required parameter 'githubSlsRestApiEncryptRequest' is not null or undefined
            assertParamExists('encrypt', 'githubSlsRestApiEncryptRequest', githubSlsRestApiEncryptRequest)
            const localVarPath = `/api/v1/idp/orgs/{org}/encrypt`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(githubSlsRestApiEncryptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [org] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity: async (org?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/idp/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {boolean} [raw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConfig: async (org: string, raw?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('getOrgConfig', 'org', org)
            const localVarPath = `/api/v1/idp/orgs/{org}/config`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMetadata: async (org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('getOrgMetadata', 'org', org)
            const localVarPath = `/api/v1/idp/orgs/{org}/metadata`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgRepo: async (org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('getOrgRepo', 'org', org)
            const localVarPath = `/api/v1/idp/orgs/{org}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [org] 
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogins: async (org?: string, refresh?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/idp/logins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRepos: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/idp/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (org?: string, provider?: string, refresh?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/idp/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} [org] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerLogin: async (provider: string, org?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('providerLogin', 'provider', provider)
            const localVarPath = `/api/v1/idp/logins/{provider}/login`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {boolean} [dryrun] 
         * @param {string} [commitSha] 
         * @param {string} [commitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshOrgRepoConfig: async (org: string, repo: string, dryrun?: boolean, commitSha?: string, commitRef?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('refreshOrgRepoConfig', 'org', org)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('refreshOrgRepoConfig', 'repo', repo)
            const localVarPath = `/api/v1/idp/orgs/{org}/repos/{repo}/config`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }

            if (commitSha !== undefined) {
                localVarQueryParameter['commitSha'] = commitSha;
            }

            if (commitRef !== undefined) {
                localVarQueryParameter['commitRef'] = commitRef;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {boolean} [force] 
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrgAndRepo: async (org: string, repo: string, force?: boolean, create?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('setOrgAndRepo', 'org', org)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('setOrgAndRepo', 'repo', repo)
            const localVarPath = `/api/v1/idp/orgs/{org}/repos/{repo}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (create !== undefined) {
                localVarQueryParameter['create'] = create;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IDPApi - functional programming interface
 * @export
 */
export const IDPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IDPApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} role 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assumeRole(role: string, org?: string, provider?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiSamlResponseContainer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assumeRole(role, org, provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} role 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assumeRoleForBrowser(role: string, org?: string, provider?: string, token?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiAssumeBrowserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assumeRoleForBrowser(role, org, provider, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {string} role 
         * @param {string} [provider] 
         * @param {string} [commitSha] 
         * @param {string} [configOwner] 
         * @param {string} [configPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assumeRoleForRepo(org: string, repo: string, role: string, provider?: string, commitSha?: string, configOwner?: string, configPath?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiSamlResponseContainer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assumeRoleForRepo(org, repo, role, provider, commitSha, configOwner, configPath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async encrypt(org: string, githubSlsRestApiEncryptRequest: GithubSlsRestApiEncryptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiEncryptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.encrypt(org, githubSlsRestApiEncryptRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [org] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentity(org?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiIdentityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentity(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {boolean} [raw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgConfig(org: string, raw?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiConfigV20220101>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgConfig(org, raw, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgMetadata(org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgMetadata(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgRepo(org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiOrgRepoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgRepo(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [org] 
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogins(org?: string, refresh?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiListResponseLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogins(org, refresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgRepos(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiListResponseOrgRepoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgRepos(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(org?: string, provider?: string, refresh?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiListResponseRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(org, provider, refresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} [org] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerLogin(provider: string, org?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiLoginResponseContainer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerLogin(provider, org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {boolean} [dryrun] 
         * @param {string} [commitSha] 
         * @param {string} [commitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshOrgRepoConfig(org: string, repo: string, dryrun?: boolean, commitSha?: string, commitRef?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiOrgRepoConfigRefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshOrgRepoConfig(org, repo, dryrun, commitSha, commitRef, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {boolean} [force] 
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrgAndRepo(org: string, repo: string, force?: boolean, create?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiOrgRepoLogin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrgAndRepo(org, repo, force, create, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IDPApi - factory interface
 * @export
 */
export const IDPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IDPApiFp(configuration)
    return {
        /**
         * 
         * @param {string} role 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRole(role: string, org?: string, provider?: string, options?: any): AxiosPromise<GithubSlsRestApiSamlResponseContainer> {
            return localVarFp.assumeRole(role, org, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} role 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRoleForBrowser(role: string, org?: string, provider?: string, token?: string, options?: any): AxiosPromise<GithubSlsRestApiAssumeBrowserResponse> {
            return localVarFp.assumeRoleForBrowser(role, org, provider, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {string} role 
         * @param {string} [provider] 
         * @param {string} [commitSha] 
         * @param {string} [configOwner] 
         * @param {string} [configPath] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRoleForRepo(org: string, repo: string, role: string, provider?: string, commitSha?: string, configOwner?: string, configPath?: string, options?: any): AxiosPromise<GithubSlsRestApiSamlResponseContainer> {
            return localVarFp.assumeRoleForRepo(org, repo, role, provider, commitSha, configOwner, configPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encrypt(org: string, githubSlsRestApiEncryptRequest: GithubSlsRestApiEncryptRequest, options?: any): AxiosPromise<GithubSlsRestApiEncryptResponse> {
            return localVarFp.encrypt(org, githubSlsRestApiEncryptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [org] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentity(org?: string, options?: any): AxiosPromise<GithubSlsRestApiIdentityResponse> {
            return localVarFp.getIdentity(org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {boolean} [raw] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConfig(org: string, raw?: boolean, options?: any): AxiosPromise<GithubSlsRestApiConfigV20220101> {
            return localVarFp.getOrgConfig(org, raw, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMetadata(org: string, options?: any): AxiosPromise<GithubSlsRestApiMetadataResponse> {
            return localVarFp.getOrgMetadata(org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgRepo(org: string, options?: any): AxiosPromise<GithubSlsRestApiOrgRepoResponse> {
            return localVarFp.getOrgRepo(org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [org] 
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogins(org?: string, refresh?: boolean, options?: any): AxiosPromise<GithubSlsRestApiListResponseLoginResponse> {
            return localVarFp.listLogins(org, refresh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRepos(options?: any): AxiosPromise<GithubSlsRestApiListResponseOrgRepoResponse> {
            return localVarFp.listOrgRepos(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [org] 
         * @param {string} [provider] 
         * @param {boolean} [refresh] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(org?: string, provider?: string, refresh?: boolean, options?: any): AxiosPromise<GithubSlsRestApiListResponseRoleResponse> {
            return localVarFp.listRoles(org, provider, refresh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} [org] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerLogin(provider: string, org?: string, options?: any): AxiosPromise<GithubSlsRestApiLoginResponseContainer> {
            return localVarFp.providerLogin(provider, org, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {boolean} [dryrun] 
         * @param {string} [commitSha] 
         * @param {string} [commitRef] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshOrgRepoConfig(org: string, repo: string, dryrun?: boolean, commitSha?: string, commitRef?: string, options?: any): AxiosPromise<GithubSlsRestApiOrgRepoConfigRefreshResponse> {
            return localVarFp.refreshOrgRepoConfig(org, repo, dryrun, commitSha, commitRef, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {string} repo 
         * @param {boolean} [force] 
         * @param {boolean} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrgAndRepo(org: string, repo: string, force?: boolean, create?: boolean, options?: any): AxiosPromise<GithubSlsRestApiOrgRepoLogin> {
            return localVarFp.setOrgAndRepo(org, repo, force, create, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IDPApi - object-oriented interface
 * @export
 * @class IDPApi
 * @extends {BaseAPI}
 */
export class IDPApi extends BaseAPI {
    /**
     * 
     * @param {string} role 
     * @param {string} [org] 
     * @param {string} [provider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public assumeRole(role: string, org?: string, provider?: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).assumeRole(role, org, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} role 
     * @param {string} [org] 
     * @param {string} [provider] 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public assumeRoleForBrowser(role: string, org?: string, provider?: string, token?: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).assumeRoleForBrowser(role, org, provider, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {string} repo 
     * @param {string} role 
     * @param {string} [provider] 
     * @param {string} [commitSha] 
     * @param {string} [configOwner] 
     * @param {string} [configPath] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public assumeRoleForRepo(org: string, repo: string, role: string, provider?: string, commitSha?: string, configOwner?: string, configPath?: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).assumeRoleForRepo(org, repo, role, provider, commitSha, configOwner, configPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public encrypt(org: string, githubSlsRestApiEncryptRequest: GithubSlsRestApiEncryptRequest, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).encrypt(org, githubSlsRestApiEncryptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [org] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public getIdentity(org?: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).getIdentity(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {boolean} [raw] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public getOrgConfig(org: string, raw?: boolean, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).getOrgConfig(org, raw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public getOrgMetadata(org: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).getOrgMetadata(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public getOrgRepo(org: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).getOrgRepo(org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [org] 
     * @param {boolean} [refresh] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public listLogins(org?: string, refresh?: boolean, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).listLogins(org, refresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public listOrgRepos(options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).listOrgRepos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [org] 
     * @param {string} [provider] 
     * @param {boolean} [refresh] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public listRoles(org?: string, provider?: string, refresh?: boolean, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).listRoles(org, provider, refresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {string} [org] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public providerLogin(provider: string, org?: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).providerLogin(provider, org, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {string} repo 
     * @param {boolean} [dryrun] 
     * @param {string} [commitSha] 
     * @param {string} [commitRef] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public refreshOrgRepoConfig(org: string, repo: string, dryrun?: boolean, commitSha?: string, commitRef?: string, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).refreshOrgRepoConfig(org, repo, dryrun, commitSha, commitRef, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {string} repo 
     * @param {boolean} [force] 
     * @param {boolean} [create] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    public setOrgAndRepo(org: string, repo: string, force?: boolean, create?: boolean, options?: AxiosRequestConfig) {
        return IDPApiFp(this.configuration).setOrgAndRepo(org, repo, force, create, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateApi - axios parameter creator
 * @export
 */
export const TemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} org 
         * @param {string} [managedPolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCloudFormation: async (org: string, managedPolicy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('createCloudFormation', 'org', org)
            const localVarPath = `/api/v1/template/orgs/{org}/cloudformation`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (managedPolicy !== undefined) {
                localVarQueryParameter['managedPolicy'] = managedPolicy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {string} [templateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudFormation: async (org: string, templateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('getCloudFormation', 'org', org)
            const localVarPath = `/api/v1/template/orgs/{org}/cloudformation`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigVariables: async (org: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('getConfigVariables', 'org', org)
            const localVarPath = `/api/v1/template/orgs/{org}/configvariables`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateApi - functional programming interface
 * @export
 */
export const TemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} org 
         * @param {string} [managedPolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCloudFormation(org: string, managedPolicy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiCloudFormationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCloudFormation(org, managedPolicy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {string} [templateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCloudFormation(org: string, templateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiCloudFormationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCloudFormation(org, templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigVariables(org: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiConfigVariablesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigVariables(org, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateApi - factory interface
 * @export
 */
export const TemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateApiFp(configuration)
    return {
        /**
         * 
         * @param {string} org 
         * @param {string} [managedPolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCloudFormation(org: string, managedPolicy?: string, options?: any): AxiosPromise<GithubSlsRestApiCloudFormationResponse> {
            return localVarFp.createCloudFormation(org, managedPolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {string} [templateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudFormation(org: string, templateId?: string, options?: any): AxiosPromise<GithubSlsRestApiCloudFormationResponse> {
            return localVarFp.getCloudFormation(org, templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} org 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigVariables(org: string, options?: any): AxiosPromise<GithubSlsRestApiConfigVariablesResponse> {
            return localVarFp.getConfigVariables(org, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateApi - object-oriented interface
 * @export
 * @class TemplateApi
 * @extends {BaseAPI}
 */
export class TemplateApi extends BaseAPI {
    /**
     * 
     * @param {string} org 
     * @param {string} [managedPolicy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public createCloudFormation(org: string, managedPolicy?: string, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).createCloudFormation(org, managedPolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {string} [templateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getCloudFormation(org: string, templateId?: string, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getCloudFormation(org, templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} org 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateApi
     */
    public getConfigVariables(org: string, options?: AxiosRequestConfig) {
        return TemplateApiFp(this.configuration).getConfigVariables(org, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TotpApi - axios parameter creator
 * @export
 */
export const TotpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiTotpMethod} method 
         * @param {GithubSlsRestApiTotpRequest} githubSlsRestApiTotpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totpEnroll: async (org: string, method: GithubSlsRestApiTotpMethod, githubSlsRestApiTotpRequest: GithubSlsRestApiTotpRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'org' is not null or undefined
            assertParamExists('totpEnroll', 'org', org)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('totpEnroll', 'method', method)
            // verify required parameter 'githubSlsRestApiTotpRequest' is not null or undefined
            assertParamExists('totpEnroll', 'githubSlsRestApiTotpRequest', githubSlsRestApiTotpRequest)
            const localVarPath = `/api/v1/totp/orgs/{org}/totp/{method}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(githubSlsRestApiTotpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TotpApi - functional programming interface
 * @export
 */
export const TotpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TotpApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiTotpMethod} method 
         * @param {GithubSlsRestApiTotpRequest} githubSlsRestApiTotpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totpEnroll(org: string, method: GithubSlsRestApiTotpMethod, githubSlsRestApiTotpRequest: GithubSlsRestApiTotpRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubSlsRestApiTotpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totpEnroll(org, method, githubSlsRestApiTotpRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TotpApi - factory interface
 * @export
 */
export const TotpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TotpApiFp(configuration)
    return {
        /**
         * 
         * @param {string} org 
         * @param {GithubSlsRestApiTotpMethod} method 
         * @param {GithubSlsRestApiTotpRequest} githubSlsRestApiTotpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totpEnroll(org: string, method: GithubSlsRestApiTotpMethod, githubSlsRestApiTotpRequest: GithubSlsRestApiTotpRequest, options?: any): AxiosPromise<GithubSlsRestApiTotpResponse> {
            return localVarFp.totpEnroll(org, method, githubSlsRestApiTotpRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TotpApi - object-oriented interface
 * @export
 * @class TotpApi
 * @extends {BaseAPI}
 */
export class TotpApi extends BaseAPI {
    /**
     * 
     * @param {string} org 
     * @param {GithubSlsRestApiTotpMethod} method 
     * @param {GithubSlsRestApiTotpRequest} githubSlsRestApiTotpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TotpApi
     */
    public totpEnroll(org: string, method: GithubSlsRestApiTotpMethod, githubSlsRestApiTotpRequest: GithubSlsRestApiTotpRequest, options?: AxiosRequestConfig) {
        return TotpApiFp(this.configuration).totpEnroll(org, method, githubSlsRestApiTotpRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


